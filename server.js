const express = require('express');
const app = express();
const path = require('path')
const mongoose = require('mongoose')
const router = require('router');
const session = require('express-session');
const URLSlugs = require('mongoose-url-slugs');
const request = require('request');
const myRouter = require('./myrouter');

const { Project } = require('./db.js');		//importing the model

const cors = require('cors')


server = require('http').Server(app);

const io = require('socket.io')(server);

// for access
require('./db');
require('./db2');
const { Artwork } = require('./db2.js');


app.use(cors())
app.use(express.urlencoded({ extended: false }));



app.use(express.static(path.join(__dirname, 'public')))

app.use('/', myRouter);

// setting cookies express
const sessionOptions = {
	secret: 'secret for signing session id(store elsewhere)',
  	saveUninitialized: true,
	resave: true
}


app.use(session(sessionOptions));
// app.get('/', (req, res) => {
	// res.send('welcome to homepage')
// })
// app.get('/react', (req, res) => {
// 	res.sendFile(path.join(__dirname + '/public/build/'));
// 	console.log(req.session)
// })


/*
var project1 = new Project(
	{
    id: 1,
    title: 'Wave Generator',
    description: 'wave descrip',
    link: '/whatever',
    videoURL: './vids/wavegenerator_0x_540p.mp4',
    counts: 0
  }
);

project1.save(function (err) {
  if (err) return handleError(err);
	console.log('saved!')
  // saved!
});
*/

// var arr = [{ name: 'Star Wars' }, { name: 'The Empire Strikes Back' }];
// Movies.insertMany(arr, function(error, docs) {});


/*
Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options, callback)

// is sent as
Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options, callback)
*/

myProjects = [
		{
			id: 1,
			title: 'Wave Generator',
			description: 'In this project, I was able to mimic the real world’s wave on the web using a real-time dataset. Each wave set has is different from another. Using Perlin-noise, the wave has become truly random but also organic and natural. The user can select around 30 different stations and poll different live-data from a custom server that scrapes data every 15 minutes from Noaa. The 2d lines are generated one at a time from the lefthand side. Due to the lines drawn on a curve, it has the effect of 3d wave.',
			link: '/wave',
			videoURL: './vids/wavegenerator_0x_540p.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 2,
			title: 'Real Time VR Multiplayer Maze',
			description: 'Renders 3-dimensional maze on the web. The server can hold up to 20+ players due to the size and competence of the server. This project underscores the potential of 3-dimensional space on the web.',
			link: '/vr',
			videoURL:'./vids/VRMaze_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 3,
			title: 'Alt Tag Generator',
			description: 'This prototype first allows the user to search for artworks that they are interested in. After artworks are loaded, the user can create Alt tags(description). The descriptions generated by the audience are then stored in the NoSQL database. Because all the contributed descriptions are stored in the DB, users can look at others’ contributed works in the completed section. This prototype is an ongoing project and will likely be shown to the Metropolitan Museum.',
			link: '/alt',
			videoURL:'./vids/altgenerator_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 4,
			title: 'VR Snowfield',
			description: 'This project also uses Aframe, so it can be experienced on a mobile device as well. The candy canes are generated in random positions. The user has a sensor that detects whether the object is solid or not, and the candy cane rotates as one bump into one of them.',
			link: '/snowfield',
			videoURL: './vids/snowfield_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 5,
			title: 'VR Room',
			description: 'Aframe is built on Three.js so that they are fairly similar to work with, but Aframe allows the user to experience as a VR world right of the bat. This project can be experienced on a mobile phone seamlessly. In this room, the user can collect feathers by standing on top of a pillow, and shoot feathers as long as the feather is left in one’s inventory.',
			link: '/vrFeather',
			videoURL:'./vids/vrfeather_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 6,
			title: '2D painting to 3D',
			description: 'In this project, I broke the convention of being able to use only one Html canvas on a page. I’ve used 5 instances of Html Canvas and was able to make each canvas talk to another, using a ‘mapping’ normalizing method. The 2-dimensional canvas is then rotated in a unique way to create a 3-dimensional space on the web. The user can collect bubbles using their arrow keys. ',
			link: '/2d3d',
			videoURL:'./vids/2d3d_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 7,
			title: 'Plant Flower',
			description: 'P5 js is one of the best libraries that can make exceptional side effects based on the user’s input. Inside the Html Canvas, the user can drop seeds to watch the flowers grow. With Object-Oriented Programming, the user can plant as many as one wishes, and each flower varies from each other. Many more sequences can be added as well.',
			link: '/flower',
			videoURL:'./vids/flower_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 8,
			title: 'WebGL Three.js',
			description: 'This is a simple animation that uses Three.js to render 3-dimensional objects on the web. Three.js uses WebGL to render 3D computer graphics in a web browser, which means that the quality of the 3-dimensional space is dictated by the graphics cards of the users’ computers.',
			link: '/webglThreejs',
			videoURL:'./vids/webgl_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 9,
			title: 'Most Common Words',
			description: 'This prototype allows the user to register and log-in. The registered id and password are then saved to the database so that the user can access this app if the user decides to come back and use it again. The app shows which word appeared the most once the user submits a text to the form field. It can be a useful tool to figure out which adjectives or nouns has been repeated the most throughout the text.',
			link: '/',
			videoURL:'./vids/summary_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 10,
			title: 'Cartesian Photoshop',
			description: 'This pattern is created from the Cartesian plane that I created. One can easily plot on the grid, and then export its coordinates by pressing ‘c’ character. Using the coordinates listed out in an array, I’ve brought over to a canvas and painted each shape with a color that changes over time.',
			link: '/cartesian',
			videoURL:'./vids/cartesian_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 11,
			title: 'Selfportrait Using Cartesian Photoshop',
			description: 'This also used the Cartesian plane I made. I used to draw it on top of my picture. Any work made on the Cartesian plane can be saved as a JPG file.',
			link: '/cartesian/selfportrait',
			videoURL:'./vids/selfportrait_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 12,
			title: 'Hypertext',
			description: 'This project is solely done in plain javascript. The story is an interactive piece where the user needs to click the ‘lights-out’ button. As the user clicks and continues the journey, the user will face different options to click into, and the story varies every time the user plays. The user’s provided name is stored inside a session.',
			link: '/hypertext',
			videoURL:'./vids/hypertext_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 13,
			title: 'Words Extrusion',
			description: 'In this project, the words rotate based on the cursor’s position. The rotation makes it seem that the page itself is a 3-dimensional space rather than a flat 2-dimensional space. Words are no longer static images, but rather a fluid / responsive objects.',
			link: '/',
			videoURL:'./vids/live_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 14,
			title: 'Plane CSS3 Animation',
			description: 'In this project, I explored what CSS3 is capable of. This wall is created solely by colored "div" tags. Because it is only dependent on CSS3, it works flawlessly on a mobile device as well.',
			link: '/',
			videoURL:'./vids/cssanimation_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 15,
			title: 'Canvas Video Pixels',
			description: 'In this project, I used the canvas to grab the pixels of videos and then manipulated each pixel to create mosaic-like videos. Like this portfolio, the project plays around with the CSS3 perspective, creating a cinema-like environment on the web.',
			link: '/css3Animation',
			videoURL:'./vids/canvasanimation_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 16,
			title: 'Plane CSS3 Collage',
			description: 'Various images and videos are layered and collaged together.',
			link: '/css3Painting',
			videoURL:'./vids/csspainting_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 17,
			title: 'Vanilla Javascript',
			description: 'Using vanilla Javascript, I created a layer of obstacle in front of the website. Thus, the user has to uncover the outer layer by moving the mouse. The obstacles fly towards you when the mouse hovers on them. Once the outer layer is removed, the user can see the images and texts positioned behind the obstacles. Use Firefox for its effective performance.',
			link: '/css3Painting',
			videoURL:'./vids/vanillajs_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 18,
			title: 'Processing.js Prototypes',
			description: 'Processing is a great tool to carry out prototypes. Because it is almost identical to P5.js and Arduino, the prototypes made using Processing can be transferred to the Web and hooked with Arduino boards easily.',
			link: '/processing',
			videoURL:'./vids/processing_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 19,
			title: 'Citizen Science Blog',
			description: '',
			link: '/processing',
			videoURL:'./vids/citizenscience_0x.mp4',
			counts: 0,
			comment: []
		},
		{
			id: 20,
			title: 'Penguin Game',
			description: 'It is a simple game that allows the user to control a penguin character with arrow keys. The objective is to collect as many prizes as one can.',
			link: '/penguine',
			videoURL:'./vids/penguine_1x.mp4',
			counts: 0,
			comment: []
		}
]

myProjects.forEach((each) => {
	// Project.findByIdAndUpdate(each.id, {
	// 	id: each.id,
	// 	title: each.title,
	// 	description: each.description,
	// 	link: each.link,
	// 	videoURL: each.videoURL,
	// 	counts: each.counts
	// }, {
  //    upsert: true}, (err, result) => {
	// 		 	console.log('result saved', result)
	// 	 })
	Project.findOne({id: each.id}).lean().then(result => {
		if (result) {
			// console.log('exists!', result)
			console.log(each.comment,'each comment');
			Project.updateOne({ id: each.id}, {
		      $set: {
						id: each.id,
						title: each.title,
						description: each.description,
						link: each.link,
						videoURL: each.videoURL,
						counts: each.counts,
						comment: each.comment

		      }
			})
			.then((result)=>{
				console.log('it already exists -> has it updated??', result)
				// res.json(result)
			})
		}
		else {
			const newProject = new Project(
				{
					id: each.id,
					title: each.title,
					description: each.description,
					link: each.link,
					videoURL: each.videoURL,
					counts: each.counts,
					comment: each.comment
				}
			)
			newProject.save(function (err, saved) {
			  if (err) return handleError(err);
				console.log('saved!')
				console.log(saved)
			  // saved!
			});
		}
	})
})


app.get('/alt', function(req, res) {
		res.sendFile(path.join(__dirname + '/public/alt/'));
})

app.post('/api/altpost', function(req, res) {
  console.log(req.body,'req.body');

  new Artwork({
    type : req.body.type,
    name: req.body.name,
    medium: req.body.medium,
    artistDisplayName: req.body.artistDisplayName,
    description: req.body.description,
    id: req.body.id,
    primaryImage: req.body.primaryImage
  }).save()
    .then(()=> res.json('altpost added!'))

});

// searching artwork from mongoose db
const allowedTypes = ['artwork'];
app.get('/api/altpost', (req, res) => {

  Artwork.find({}, (err, result) => {
    res.json( result.map((g) => {
        return { name: g.name, medium: g.medium, artistDisplayName: g.artistDisplayName, description: g.description, id: g.id, primaryImage: g.primaryImage };
      }) );
  });

  // console.log(req.query,'req.query')

  // const queryObject = {};
  // const n = req.query.artworktype;
  //
  // if (n && allowedTypes.indexOf(n) > -1) {
  //   queryObject.type = n;
  // }
  // Artwork.find({}, (err, result) => {
  //   console.log(result);
  // });
  // Artwork.find(queryObject, (err, result) => {
  //   console.log(result,'result')
  //   res.json(result.map((g) => {
  //     return { type: g.type, name: g.name };
  //   }));
  // });
});





app.get('/portfolio/db', function(req, res) {
	//if doesn't exist add?


	Project.find({}, null, {sort: {'id':1}}, (err, result) => {

		res.json(result.map(each => {			//sends array object -> without uuid // res.json(result); almost as same as <-
			return {
				id: each.id,
		    title: each.title,
		    description: each.description,
		    link: each.link,
		    videoURL: each.videoURL,
		    counts: each.counts,
				comment: each.comment
			}
		}))
	});
});

app.post('/portfolio/db/comment', function(req, res) {
	// console.log(req, 'comment req query')
	// console.log(req.query, 'comment req query')
	let query = { id: req.query.projectId }
	let save = { [req.query.author]: req.query.comment }

	Project.findOneAndUpdate(query, {$push: {comment:save}}, function(err, project, count) {
		console.log(project,'UPDATED PROJECT2')	//here

		Project.find(query, function(err, found) {
			res.json(found)
		})

		// Project.find({}, (err, result) => {
		// 	console.log(result,'RESULT2')
		// 	res.json(result.map(each => {			//sends array object -> without uuid // res.json(result); almost as same as <-
		// 		// return {
		// 		// 	id: each.id,
		// 	  //   title: each.title,
		// 	  //   description: each.description,
		// 	  //   link: each.link,
		// 	  //   videoURL: each.videoURL,
		// 	  //   counts: each.counts,
		// 		// 	comment: each.comment,		//why re writing?
		// 		// }
		// 		console.log(each,'EAACH ')
		// 		return Object.assign({}, each, {
		// 			id: each.id,
		// 	    title: each.title,
		// 	    description: each.description,
		// 	    link: each.link,
		// 	    videoURL: each.videoURL,
		// 	    counts: each.counts,
		// 			comment: each.comment,
		//     })
		// 	}))
		// });


	})
	// let update = {
	// 	$set: {
	// 		hi: 'bb'			//assuming counts and id are posted
	// 	}
	// }
	// Project.findOne(query).then(result => {
	// 	if (result.comment != undefined) {
	// 		console.log(result.comment, 'here')
	// 		console.log('comment exists!')
	// 		result.comment.push({name: 'mushroom'});
	// 		 result.save(function(saveErr, savePizza, saveCount) {
	// 			 console.log(savePizza);
	// 		 });
	//
	// 	} else {
	// 		console.log('nah')
	// 		Object.assign(result, {comment: 'b'});
	// 		console.log(result,'result')
	// 		result.save(function(saveErr, savePizza, saveCount) {
	// 			console.log(savePizza);
	// 		});
	// 	}
	// }
	// new Cat({
  //   query: req.query.projectId,
  //   comment : Date.now()
  // }).save(function(err, res, count){
  //   // res.redirect('/cats');
  // });
	// Project.updateOne(query, {$set: {'title':'Wave Finder'}}, (result)=> {
	// 	console.log(result, 'result')
	// })

	//
	// Project.findOne(query, function(err, project, count) {
	//
	// 		project.comment.push({name: 'mushroom'});
 	// 		project.save(function(saveErr, savePizza, saveCount) {
	//      	console.log(savePizza);
	//    	});
	//  })
	// .then(()=>{


	// })

})

app.post('/portfolio/db', function(req, res) {
	// console.log(req, 'req');
	// console.log(req.query, 'req.query');
	// Project.find({id:req.body.id}, (err, result) => {
	//
	// })

	Project.updateOne({ id: req.query.id }, {
      $set: {
        counts: req.query.counts			//assuming counts and id are posted
      }
	}).then((result)=>{
		console.log('has it updated??', result);
		// res.json(result)
	}).then(()=>{
		Project.find({}, (err, result) => {
			res.json(result.map(each => {			//sends array object -> without uuid // res.json(result); almost as same as <-
				return {
					id: each.id,
			    title: each.title,
			    description: each.description,
			    link: each.link,
			    videoURL: each.videoURL,
			    counts: each.counts
				}
			}))
		});
	})

	// new Project({
	// 	id: req.body.id,
	// 	title: req.body.title,
	// 	description: req.body.description,
	// 	link: req.body.link,
	// 	videoURL: req.body.videoURL,
	// 	counts: req.body.counts
	// }).save()
	// .then(()=> res.json('project post has been made!'))

});




// socket vr starts here

/* !important for wave  */
// global
var acc;
var my_lat_lon = null;
let areacode;

app.get('/mydata', function(req, res, next) {
	if (areacode != null) {
	} else if (areacode == null) {
			areacode = {areacode: 52200}
	}
	console.log(areacode,'AREACODE')

	console.log('get -> areacode.areacode : ', areacode.areacode);

	return new Promise((resolve, reject) => {
			request(`http://coolwx.com/cgi-bin/findbuoy.cgi?id=${areacode.areacode}`, function(error, response, html){
				if(error) {
					console.log('err occured while requesting');
				}
				if(!error){
					const splitData = html.split("<HR>")[1];
					const splitData2 = splitData.split("</PRE>")[0]
					const lines = splitData2.split(/\r\n|\n|\r/);

					heights = [];
					periods = [];
					acc = 'Height,Period '
					for (let i = 1; i < lines.length - 1; i ++) {
						let lat_lon = lines[i].substr(13, 11);
						my_lat_lon = lat_lon;

						let height = lines[i].substr(71, 4);
						let period = lines[i].substr(76, 2);

						if (height == '    ' || period == '  '){
						} else{
							acc += height
							acc += ','
							acc += period
							acc += '\n'
						}
					}
					console.log('my_lat_lon in scraping 1 : ', my_lat_lon)
					// console.log('acc in scraping 1 : ', acc)
					console.log('scraping finished')
					resolve('thanks for waiting')
				}
			});
		}).then((resolve)=>{
			console.log(resolve)
			res.send(`${acc}<br\/>${my_lat_lon}`);
		});
});

app.post('/mydata', function(req, res, next) {
  if(req.body) {
    req.session.areacode = req.body;
    console.log('post -> assigned req.session.areacode : ', req.session.areacode);
  }
  else {
    console.warn('req body does not exist');
  }
  areacode = req.body;
  console.log('post -> areacode.areacode after posting: ', areacode.areacode)
	// scrape(areacode.areacode);
	// res.send(`${acc}<br\/>${my_lat_lon}`);
});





// app.use(express.static('public'));

let ping = 0;
let playerArrayServer = [];

class Player {
  constructor(xPos, yPos, zPos, userId, yRotation) {
    this.xPos = xPos;
    this.yPos = yPos;
    this.zPos = zPos;
    this.userId = userId;
    this.yRotation = yRotation;
    this.yCurrentRotation = 0;
  }
}

let temp_map = [
  [1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,3,0,3,0,0,0,0,1],
  [1,0,3,3,3,0,3,0,3,3,0,1],
  [1,0,0,0,0,0,3,0,3,0,0,1],
  [1,0,3,3,3,3,3,0,3,3,3,1],
  [1,0,0,0,0,0,0,0,0,0,0,1],
  [1,3,3,3,0,3,3,3,3,3,0,1],
  [1,0,0,3,0,3,0,0,0,0,0,1],
  [1,0,0,0,0,3,0,3,3,3,3,1],
  [1,0,3,0,0,3,0,0,0,0,0,1],
  [1,0,3,3,3,3,3,3,3,3,0,1],
  [1,0,3,5,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1]
];

function generateMap(arg) {
  let copy = [...arg];
  let treasureLocRow = Math.floor(Math.random() * temp_map.length + 1)
  let treasurePlaced = '';

  copy.forEach((each, index) => {
    if (index === 0 || index === (copy.length - 1)) { }
    else if (index === treasureLocRow) {
      each.forEach((item, i) => {
        if (i === 0 || i === (each.length - 1)) {

        } else {

          ranItemNumber = Math.floor(Math.random() * 3)
          ranItemNumber == 0 || ranItemNumber == 1 ? copy[index][i] = 0 : copy[index][i] = 3

          if(treasurePlaced == '') {
            if (ranItemNumber === 2) {

              copy[index][i] = 5
              console.log('treasure placed with 5')
              treasurePlaced = true;

            }
          }
        }
      })
    }
    else {
      each.forEach((item, i) => {
        if (i === 0 || i === (each.length - 1)) {

        } else {


          ranItemNumber = Math.floor(Math.random() * 3)
          console.log(ranItemNumber);
          //add treasure
          ranItemNumber == 0 || ranItemNumber == 1 ? copy[index][i] = 0 : copy[index][i] = 3
        }
      });
    }
  });
  return copy;
}

let newMap = generateMap(temp_map);
console.log(newMap,'newmap');

io.on('connect', (socket) => {
  console.log(socket.id, " : player has connected");

  socket.on('setupReady', () => {
      io.emit('newMap', {newMap: newMap});
  });

  socket.on('worldReady',function(){
      io.emit('currentPlayers', {currentPlayers: playerArrayServer} );
  });

  // let initX = Math.floor(Math.random() * 10);
  // let initY = 0;
  // let initZ = Math.floor(Math.random() * 10);

  let initX = 0;
  let initY = 0;
  let initZ = 0;


  playerArrayServer.push(new Player(initX, initY, initZ,  socket.id, 0));
  console.log('Current number of player is : ', playerArrayServer.length );


  //this updates the class everytime a player is moved, then the updated position becomes the initital pos for new incoming players

  socket.on('sendBack_newPos', function(data) {

    console.warn(ping ,' ping');
    ping += 1

    playerArrayServer.forEach((each) => {
      if (each.userId == data.userId){

          each.xPos = data.newPosX;
          each.yPos = data.newPosY;
          each.zPos = data.newPosZ;
          each.yCurrentRotation = data.yCurrentRotation;
      }

      io.emit('broadcast', {xPos: each.xPos,
                                yPos: each.yPos,
                                zPos: each.zPos,
                                userId: each.userId,
                                yCurrentRotation: each.yCurrentRotation
                              });
    });
  });

/*
  socket.on('rotateMyPlayer', function(data) {
    // console.log('data.yRotation recieved', data.yRotation)

    playerArrayServer.forEach((each) => {
      if (data.playerId == each.userId) {
        // each.yRotation += 2;

        if (data.direction === 37) {
          // each.yRotation += 0.03;
          each.yRotation = 1;

        } else if (data.direction === 39) {
          // each.yRotation -= 0.03;
          each.yRotation = -1;
        }
          //should I emit 'broadcast'?
      }
    });
  });
*/

  //!important = this is what's setting the position of users - both initial and changed position
  // console.log(playerArrayServer,'playerArrayServer -> before sending out Position & Rotation');

  socket.on('debug', function(data) {
    console.log(playerArrayServer,'playerArrayServer -> before sending out Position & Rotation');
  });



  // xPos: 0,
  // yPos: 0,
  // zPos: -5,
  // they all used to have this - which is defined in init

  socket.on('disconnect', function() {
    console.log(socket.id, 'disconnected');
    console.log('Number of playerArrayServer is ', playerArrayServer.length );

    for (let j = 0; j < playerArrayServer.length; j++) {
        if (playerArrayServer[j].userId == socket.id) {
          console.log(socket.id,' Bye!');

          playerArrayServer.splice(j, 1);
          j -= 1;
        }
    }
    console.log('Number of playerArrayServer is ', playerArrayServer.length );

    io.emit('disconnect', {id: socket.id});
  });
});







const PORT = process.env.PORT || 3535;
// app.listen(PORT);
server.listen(PORT);			//due to socket.io
console.log(`server started on port ${PORT}`)
